export interface CapacitorUpdaterPlugin {
    /**
   * Download a new version from the provided URL, it should be a zip file, with files inside or with a unique folder inside with all your files
   * @returns {Promise<{version: string}>} an Promise with version name of the downloaded version, version is generated by the plugin, it's a random string of 10 char length
   * @param url The URL where download the version, it can be S3 github tag or whatever, it should be a zip file
   */
  download(options: { url: string }): Promise<{ version: string }>;
    /**
   * Set version as current version, set will return an error if there are is no index.html file inside the version folder. `versionName` is optional and it's a custom value that will be saved for you
   * @returns {Promise<void>} an empty Promise when the version is set, if there are no index.html or no version folder throw an error
   * @param version The version name to set as current version
   */
  set(options: { version: string, versionName?: string }): Promise<void>;
    /**
   * Delete version in storage
   * @returns {Promise<void>} an empty Promise when the version is delete, otherwise throw an error
   * @param version The version name to delete
   */
  delete(options: { version: string }): Promise<void>;
    /**
   * Get all available versions
   * @returns {Promise<{version: string[]}>} an Promise witht the version list
   */
  list(): Promise<{ versions: string[] }>;
    /**
   * Set the `builtin` version (the one sent to Apple store / Google play store ) as current version
   * @returns {Promise<void>} an empty Promise
   * @param toAutoUpdate [false] if yes it reset to to the last AutoUpdate version instead of `builtin`
   */
  reset({ toAutoUpdate: boolean }): Promise<void>;
    /**
   * Get the current version, if none are set it returns `builtin`
   * @returns {Promise<{ current: string }>} an Promise with the current version name
   */
  current(): Promise<{ current: string }>;
    /**
   * Reload the view
   * @returns {Promise<void>} an Promise resolved when the view is reloaded
   */
  reload(): Promise<void>;
    /**
   * Get the version name, if it was set during the set phase
   * @returns {Promise<{ versionName: string }>} an Promise witht the current versionName
   */
  versionName(): Promise<{ versionName: string }>;
  /**
   * Notify native plugin that the update is working, only in auto-update
   * @returns {Promise<void>} an Promise resolved directly
   */
  notifyAppReady(): Promise<void>;
  /**
   * Skip updates in the next time the app goes into the background, only in auto-update
   * @returns {Promise<void>} an Promise resolved directly
   */
  delayUpdate(): Promise<void>;
  /**
   * allow update in the next time the app goes into the background, only in auto-update
   * @returns {Promise<void>} an Promise resolved directly
   */
  cancelDelay(): Promise<void>;
}
