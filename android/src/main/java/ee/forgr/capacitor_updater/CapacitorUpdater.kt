package ee.forgr.capacitor_updater

import com.android.volley.RequestQueue
import android.content.SharedPreferences
import java.io.FilenameFilter
import java.io.File
import java.lang.StringBuilder
import kotlin.Throws
import java.io.IOException
import java.util.zip.ZipInputStream
import java.io.BufferedInputStream
import java.io.FileInputStream
import java.util.zip.ZipEntry
import java.io.FileNotFoundException
import java.io.FileOutputStream
import android.util.Log
import java.net.URL
import java.io.DataInputStream
import kotlin.jvm.JvmOverloads
import com.android.volley.toolbox.StringRequest
import com.android.volley.AuthFailureError
import com.android.volley.Response
import com.getcapacitor.plugin.WebView
import org.json.JSONException
import org.json.JSONObject
import java.lang.Exception
import java.lang.Thread
import java.net.HttpURLConnection
import java.io.DataOutputStream
import java.security.SecureRandom
import java.text.SimpleDateFormat
import java.util.*

open class CapacitorUpdater {
    lateinit var prefs: SharedPreferences
    lateinit var editor: SharedPreferences.Editor
    lateinit var versionOs: String
    lateinit var deviceID: String
    lateinit var statsUrl: String
    lateinit var appId: String
    lateinit var requestQueue: RequestQueue
    lateinit var versionBuild: String
    lateinit var versionCode: String
    private val bundleDirectory = "versions"
    private var documentsDir = ""


    private val filter = FilenameFilter { _, name -> // ignore directories generated by mac os x
        !name.startsWith("__MACOSX") && !name.startsWith(".") && !name.startsWith(".DS_Store")
    }

    private fun calcTotalPercent(percent: Int, min: Int, max: Int): Int {
        return percent * (max - min) / 100 + min
    }

    open fun notifyDownload(percent: Int) {
        return
    }

    private fun randomString(len: Int): String {
        val sb = StringBuilder(len)
        for (i in 0 until len) sb.append(AB[rnd.nextInt(AB.length)])
        return sb.toString()
    }

    @Throws(IOException::class)
    private fun unzip(zipFile: File, dest: String): File {
        val targetDirectory = File("$documentsDir/$dest")
        val zis = ZipInputStream(BufferedInputStream(FileInputStream(zipFile)))
        return try {
            var count: Int
            val bufferSize = 8192
            val buffer = ByteArray(bufferSize)
            val lengthTotal = zipFile.length()
            var lengthRead: Long = bufferSize.toLong()
            var percent = 0
            notifyDownload(75)
            var entry: ZipEntry
            while (zis.nextEntry.also { entry = it } != null) {
                val file = File(targetDirectory, entry.name)
                val canonicalPath = file.canonicalPath
                val canonicalDir = File(targetDirectory.toString()).canonicalPath
                val dir = if (entry.isDirectory) file else file.parentFile
                if (!canonicalPath.startsWith(canonicalDir)) {
                    throw FileNotFoundException(
                        "SecurityException, Failed to ensure directory is the start path : " +
                                canonicalDir + " of " + canonicalPath
                    )
                }
                if (!dir.isDirectory && !dir.mkdirs()) {
                    throw FileNotFoundException(
                        "Failed to ensure directory: " +
                                dir.absolutePath
                    )
                }
                if (entry.isDirectory) {
                    continue
                }
                FileOutputStream(file).use { outputStream ->
                    while (zis.read(buffer).also { count = it } != -1) outputStream.write(
                        buffer,
                        0,
                        count
                    )
                }
                val newPercent = (lengthRead * 100 / lengthTotal).toInt()
                if (lengthTotal > 1 && newPercent != percent) {
                    percent = newPercent
                    notifyDownload(calcTotalPercent(percent, 75, 90))
                }
                lengthRead += entry.compressedSize
            }
            targetDirectory
        } finally {
            try {
                zis.close()
            } catch (e: IOException) {
                Log.e(TAG, "Failed to close zip input stream", e)
            }
        }
    }

    @Throws(IOException::class)
    private fun flattenAssets(sourceFile: File, dest: String) {
        if (!sourceFile.exists()) {
            throw FileNotFoundException("Source file not found: " + sourceFile.path)
        }
        val destinationFile = File("$documentsDir/$dest")
        destinationFile.parentFile.mkdirs()
        val entries = sourceFile.list(filter)
        if (entries == null || entries.isEmpty()) {
            throw IOException("Source file was not a directory or was empty: " + sourceFile.path)
        }
        if (entries.size == 1 && entries[0] != "index.html") {
            val child = File(sourceFile.path + "/" + entries[0])
            child.renameTo(destinationFile)
        } else {
            sourceFile.renameTo(destinationFile)
        }
        sourceFile.delete()
    }

    @Throws(IOException::class)
    private fun downloadFile(url: String, dest: String): File {
        val u = URL(url)
        val connection = u.openConnection()
        val `is` = u.openStream()
        val dis = DataInputStream(`is`)
        val target = File("$documentsDir/$dest")
        target.parentFile.mkdirs()
        target.createNewFile()
        val fos = FileOutputStream(target)
        val totalLength = connection.contentLength.toLong()
        val bufferSize = 1024
        val buffer = ByteArray(bufferSize)
        var length: Int
        var bytesRead = bufferSize
        var percent = 0
        notifyDownload(10)
        while (dis.read(buffer).also { length = it } > 0) {
            fos.write(buffer, 0, length)
            val newPercent = (bytesRead * 100 / totalLength).toInt()
            if (totalLength > 1 && newPercent != percent) {
                percent = newPercent
                notifyDownload(calcTotalPercent(percent, 10, 70))
            }
            bytesRead += length
        }
        return target
    }

    @Throws(IOException::class)
    private fun deleteDirectory(file: File) {
        if (file.isDirectory) {
            val entries = file.listFiles()
            if (entries != null) {
                for (entry in entries) {
                    deleteDirectory(entry)
                }
            }
        }
        if (!file.delete()) {
            throw IOException("Failed to delete $file")
        }
    }

    private fun setCurrentBundle(bundle: File) {
        editor!!.putString(WebView.CAP_SERVER_PATH, bundle.path)
        Log.i(TAG, "Current bundle set to: $bundle")
        editor!!.commit()
    }

    @Throws(IOException::class)
    fun download(url: String, versionName: String?): VersionInfo {
        notifyDownload(0)
        val path = randomString(10)
        val zipFile = File("$documentsDir/$path")
        val folderNameUnZip = randomString(10)
        val version = randomString(10)
        val folderName = "$bundleDirectory/$version"
        notifyDownload(5)
        val downloaded = downloadFile(url, path)
        notifyDownload(71)
        val unzipped = this.unzip(downloaded, folderNameUnZip)
        zipFile.delete()
        notifyDownload(91)
        flattenAssets(unzipped, folderName)
        notifyDownload(100)
        setVersionStatus(version, VersionStatus.PENDING)
        setVersionDownloadedTimestamp(version, Date(System.currentTimeMillis()))
        setVersionName(version, versionName)
        return getVersionInfo(version)
    }

    fun list(): ArrayList<VersionInfo> {
        val res = ArrayList<VersionInfo>()
        val destHot = File("$documentsDir/$bundleDirectory")
        Log.i(TAG, "list File : " + destHot.path)
        if (destHot.exists()) {
            for (i in destHot.listFiles()) {
                val version = i.name
                res.add(getVersionInfo(version))
            }
        } else {
            Log.i(TAG, "No version available$destHot")
        }
        return res
    }

    @Throws(IOException::class)
    fun delete(version: String): Boolean {
        val deleted = getVersionInfo(version)
        val bundle = File("$documentsDir/$bundleDirectory/$version")
        if (bundle.exists()) {
            deleteDirectory(bundle)
            removeVersionInfo(version)
            return true
        }
        Log.i(TAG, "Directory not removed: " + bundle.path)
        sendStats("delete", deleted)
        return false
    }

    private fun getBundleDirectory(version: String): File {
        return File("$documentsDir/$bundleDirectory/$version")
    }

    private fun bundleExists(bundle: File?): Boolean {
        return if (bundle == null || !bundle.exists()) {
            false
        } else File(bundle.path + "/index.html").exists()
    }

    fun set(version: VersionInfo): Boolean {
        return this.set(version.version)
    }

    fun set(version: String): Boolean {
        val existing = getVersionInfo(version)
        val bundle = getBundleDirectory(version)
        Log.i(TAG, "Setting next active bundle $existing")
        if (bundleExists(bundle)) {
            setCurrentBundle(bundle)
            setVersionStatus(version, VersionStatus.PENDING)
            sendStats("set", existing)
            return true
        }
        sendStats("set_fail", existing)
        return false
    }

    fun commit(version: VersionInfo) {
        setVersionStatus(version.version, VersionStatus.SUCCESS)
        fallbackVersion = version
    }

    fun rollback(version: VersionInfo) {
        setVersionStatus(version.version, VersionStatus.ERROR)
    }

    @JvmOverloads
    fun reset(internal: Boolean = false) {
        setCurrentBundle(File("public"))
        fallbackVersion = null
        setNextVersion(null)
        if (!internal) {
            sendStats("reset", currentBundle)
        }
    }

    fun getLatest(url: String?, callback: (JSONObject) -> Unit) {
        val deviceID = deviceID
        val appId = appId
        val versionBuild = versionBuild
        val versionCode = versionCode
        val versionOs = versionOs
        val pluginVersion: String = pluginVersion
        val versionName = currentBundle.name
        val stringRequest: StringRequest = object : StringRequest(
            Method.GET, url,
            Response.Listener { response ->
                try {
                    val jsonObject = JSONObject(response)
                    callback(jsonObject)
                } catch (e: JSONException) {
                    Log.e(TAG, "Error parsing JSON", e)
                }
            }, Response.ErrorListener { error -> Log.e(TAG, "Error getting Latest$error") }) {
            @Throws(AuthFailureError::class)
            override fun getHeaders(): Map<String, String> {
                val params: MutableMap<String, String> = HashMap()
                params["cap_platform"] = "android"
                params["cap_device_id"] = deviceID
                params["cap_app_id"] = appId
                params["cap_version_build"] = versionBuild
                params["cap_version_code"] = versionCode
                params["cap_version_os"] = versionOs
                params["cap_version_name"] = versionName
                params["cap_plugin_version"] = pluginVersion
                return params
            }
        }
        requestQueue!!.add(stringRequest)
    }

    private fun sendStats(action: String, version: VersionInfo) {
        if (statsUrl === "") {
            return
        }
        val url: URL
        val json = JSONObject()
        val jsonString: String
        try {
            url = URL(statsUrl)
            json.put("platform", "android")
            json.put("action", action)
            json.put("version_name", version)
            json.put("device_id", deviceID)
            json.put("version_build", versionBuild)
            json.put("version_code", versionCode)
            json.put("version_os", versionOs)
            json.put("plugin_version", pluginVersion)
            json.put("app_id", appId)
            jsonString = json.toString()
        } catch (ex: Exception) {
            Log.e(TAG, "Error get stats", ex)
            return
        }
        Thread {
            var con: HttpURLConnection? = null
            try {
                con = url.openConnection() as HttpURLConnection
                con!!.requestMethod = "POST"
                con.setRequestProperty("Content-Type", "application/json")
                con.setRequestProperty("Accept", "application/json")
                con.setRequestProperty(
                    "Content-Length",
                    Integer.toString(jsonString.toByteArray().size)
                )
                con.doOutput = true
                con.connectTimeout = 500
                val wr = DataOutputStream(con.outputStream)
                wr.writeBytes(jsonString)
                wr.close()
                val responseCode = con.responseCode
                if (responseCode != 200) {
                    Log.e(TAG, "Stats error responseCode: $responseCode")
                } else {
                    Log.i(TAG, "Stats send for \"$action\", version $version")
                }
            } catch (ex: Exception) {
                Log.e(TAG, "Error post stats", ex)
            } finally {
                con?.disconnect()
            }
        }.start()
    }

    fun getVersionInfo(version: String?): VersionInfo {
        var version = version
        if (version == null) {
            version = "unknown"
        }
        val downloaded = getVersionDownloadedTimestamp(version)
        val name = getVersionName(version)
        val status = getVersionStatus(version)
        return VersionInfo(version, status, downloaded, name)
    }

    private fun removeVersionInfo(version: String) {
        setVersionDownloadedTimestamp(version, null)
        setVersionName(version, null)
        setVersionStatus(version, null)
    }

    private fun getVersionDownloadedTimestamp(version: String): String? {
        return prefs!!.getString(version + DOWNLOADED_SUFFIX, "")
    }

    private fun setVersionDownloadedTimestamp(version: String?, time: Date?) {
        if (version != null) {
            Log.i(TAG, "Setting version download timestamp $version to $time")
            if (time == null) {
                editor!!.remove(version + DOWNLOADED_SUFFIX)
            } else {
                val sdf: SimpleDateFormat = SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSZ")
                sdf.timeZone = TimeZone.getTimeZone("CET")
                val isoDate = sdf.format(time)
                editor!!.putString(version + DOWNLOADED_SUFFIX, isoDate)
            }
            editor!!.commit()
        }
    }

    private fun getVersionName(version: String): String? {
        return prefs!!.getString(version + NAME_SUFFIX, "")
    }

    fun setVersionName(version: String?, name: String?) {
        if (version != null) {
            Log.i(TAG, "Setting version name $version to $name")
            if (name == null) {
                editor!!.remove(version + NAME_SUFFIX)
            } else {
                editor!!.putString(version + NAME_SUFFIX, name)
            }
            editor!!.commit()
        }
    }

    private fun getVersionStatus(version: String): VersionStatus {
        return VersionStatus.fromString(prefs!!.getString(version + STATUS_SUFFIX, "pending"))
    }

    private fun setVersionStatus(version: String?, status: VersionStatus?) {
        if (version != null) {
            Log.i(TAG, "Setting version status $version to $status")
            if (status == null) {
                editor!!.remove(version + STATUS_SUFFIX)
            } else {
                editor!!.putString(version + STATUS_SUFFIX, status.label)
            }
            editor!!.commit()
        }
    }

    private val currentBundleVersion: String
        private get() = if (isUsingBuiltin) {
            VersionInfo.VERSION_BUILTIN
        } else {
            val path = currentBundlePath
            path!!.substring(path.lastIndexOf('/') + 1)
        }
    val currentBundle: VersionInfo
        get() = getVersionInfo(currentBundleVersion)
    val currentBundlePath: String?
        get() = prefs!!.getString(WebView.CAP_SERVER_PATH, "public")
    val isUsingBuiltin: Boolean
        get() = currentBundlePath == "public"
    var fallbackVersion: VersionInfo?
        get() {
            val version = prefs!!.getString(FALLBACK_VERSION, VersionInfo.VERSION_BUILTIN)
            return getVersionInfo(version)
        }
        private set(fallback) {
            editor!!.putString(
                FALLBACK_VERSION,
                if (fallback == null) VersionInfo.VERSION_BUILTIN else fallback.version
            )
        }
    val nextVersion: VersionInfo?
        get() {
            val version = prefs!!.getString(NEXT_VERSION, "")
            return if (version !== "") {
                getVersionInfo(version)
            } else {
                null
            }
        }

    fun setNextVersion(next: String?): Boolean {
        if (next == null) {
            editor!!.remove(NEXT_VERSION)
        } else {
            val bundle = getBundleDirectory(next)
            if (!bundleExists(bundle)) {
                return false
            }
            editor!!.putString(NEXT_VERSION, next)
        }
        editor!!.commit()
        return true
    }

    companion object {
        private const val AB = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"
        private val rnd = SecureRandom()
        private const val DOWNLOADED_SUFFIX = "_downloaded"
        private const val NAME_SUFFIX = "_name"
        private const val STATUS_SUFFIX = "_status"
        private const val FALLBACK_VERSION = "pastVersion"
        private const val NEXT_VERSION = "nextVersion"
        const val TAG = "Capacitor-updater"
        const val pluginVersion = "3.3.2"
    }
}